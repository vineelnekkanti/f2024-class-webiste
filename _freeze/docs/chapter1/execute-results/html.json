{
  "hash": "43dded24b620fd46a76b157b59b88375",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Chapter 1: Manipulations\"\nauthor: \"Biagio Palese\"\ndate: \"24 August, 2024\" \nformat: \n  html:\n    toc: TRUE\n    toc_float: TRUE\n    code_download: TRUE\n---\n\n<script>\nif (localStorage.getItem(\"isLoggedIn\") !== \"true\") {\n    window.location.href = \"login.html\";\n}\n</script>\n\n\n\n\n\n\n## Manipulations\n\n![When working on a new dataset the beginning might not be easy](images/course_images/manipulations.png)\n\nThe following sections of our book R for Data Science( [first portion of the course book](https://r4ds.hadley.nz) ) are included in the second week:\n\n-   [Data Transformation](https://r4ds.hadley.nz/data-transform): Sections: from 3 to 3.3 & part of 3.5 included\n\n### Link to other resources\n\n-   Internal help: [posit support](https://support.posit.co/hc/en-us)\n\n-   External help: [stackoverflow](https://stackoverflow.com/search?q=rstudio&s=25d8522e-3191-4bf2-ae3b-ccad762aeca9)\n\n-   Additional materials: [posit resources](https://posit.co/resources/)\n\n-   Cheat Sheets: [posit cheat sheets](https://posit.co/resources/cheatsheets/)\n\nWhile I use the book as a reference the materials provided to you are custom made and include more activities and resources. If you understand the materials covered in this document there is no need to refer to other sources. If you have any troubles with the materials don't hesitate to contact me or check the above sources.\n\n### Load packages\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(nycflights13)\n```\n:::\n\n\n\n\n![Data Science model: Artwork by @allison_horst](images/environmental-data-science-r4ds-general.png)\n\n### Get to know your data\n\n\n\n\n::: {.cell exercise='false'}\n\n```{.r .cell-code}\nflights#dataset we will use --> make sure you run library(nycflights13) before running this line of code\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,000 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     4      819            820        -1     1103           1129\n 2  2013    12     5     1238           1110        88     1342           1223\n 3  2013     8    19     1953           1959        -6     2141           2146\n 4  2013     4    14      608            610        -2      752            754\n 5  2013     4    29     1653           1700        -7     1815           1835\n 6  2013     4     5     1813           1729        44     2026           1937\n 7  2013     1    17     1740           1745        -5     2054           2120\n 8  2013     2    26      834            815        19     1031           1010\n 9  2013     2    20     1014           1000        14     1219           1221\n10  2013     3    22     1741           1736         5     2024           2029\n# ℹ 14,990 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n?flights # get a description of it\n#view(flights)# run this if you want to explore the entire dataset --> which will open the dataset in the RStudio viewer.\nglimpse(flights)# run this if you want a summary of the dataset \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 15,000\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 12, 8, 4, 4, 4, 1, 2, 2, 3, 1, 2, 12, 8, 7, 9, 9, 12…\n$ day            <int> 4, 5, 19, 14, 29, 5, 17, 26, 20, 22, 25, 18, 13, 5, 29,…\n$ dep_time       <int> 819, 1238, 1953, 608, 1653, 1813, 1740, 834, 1014, 1741…\n$ sched_dep_time <int> 820, 1110, 1959, 610, 1700, 1729, 1745, 815, 1000, 1736…\n$ dep_delay      <dbl> -1, 88, -6, -2, -7, 44, -5, 19, 14, 5, 4, -2, -5, -7, 1…\n$ arr_time       <int> 1103, 1342, 2141, 752, 1815, 2026, 2054, 1031, 1219, 20…\n$ sched_arr_time <int> 1129, 1223, 2146, 754, 1835, 1937, 2120, 1010, 1221, 20…\n$ arr_delay      <dbl> -26, 79, -5, -2, -20, 49, -26, 21, -2, -5, -4, -19, -9,…\n$ carrier        <chr> \"B6\", \"EV\", \"EV\", \"EV\", \"MQ\", \"EV\", \"AA\", \"MQ\", \"EV\", \"…\n$ flight         <int> 181, 4633, 4462, 4555, 4255, 4621, 177, 4490, 3810, 9, …\n$ tailnum        <chr> \"N527JB\", \"N14974\", \"N11176\", \"N14148\", \"N645MQ\", \"N145…\n$ origin         <chr> \"JFK\", \"EWR\", \"LGA\", \"LGA\", \"JFK\", \"EWR\", \"JFK\", \"LGA\",…\n$ dest           <chr> \"SAN\", \"BTV\", \"CLE\", \"CLE\", \"BNA\", \"CVG\", \"SFO\", \"CMH\",…\n$ air_time       <dbl> 312, 47, 62, 73, 108, 92, 352, 80, 109, 135, 190, 138, …\n$ distance       <dbl> 2446, 266, 419, 419, 765, 569, 2586, 479, 708, 944, 159…\n$ hour           <dbl> 8, 11, 19, 6, 17, 17, 17, 8, 10, 17, 7, 6, 7, 11, 15, 8…\n$ minute         <dbl> 20, 10, 59, 10, 0, 29, 45, 15, 0, 36, 10, 59, 7, 15, 5,…\n$ time_hour      <dttm> 2013-01-04 08:00:00, 2013-12-05 11:00:00, 2013-08-19 1…\n```\n\n\n:::\n\n```{.r .cell-code}\ncolnames(flights)# know the columns name of your dataset\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"year\"           \"month\"          \"day\"            \"dep_time\"      \n [5] \"sched_dep_time\" \"dep_delay\"      \"arr_time\"       \"sched_arr_time\"\n [9] \"arr_delay\"      \"carrier\"        \"flight\"         \"tailnum\"       \n[13] \"origin\"         \"dest\"           \"air_time\"       \"distance\"      \n[17] \"hour\"           \"minute\"         \"time_hour\"     \n```\n\n\n:::\n:::\n\n\n\n\n### Data types\n\nOnly the most used ones are covered below:\n\n-   *int* stands for integers (1,2,3).\n\n-   *dbl* stands for doubles, or real numbers (-1, 1.5,4/5).\n\n-   *chr* stands for character vectors, or strings (\"this is a string\").\n\n-   *fctr* stands for factors, which R uses to represent categorical variables with fixed possible values (freshman, sophomore, junior, senior).\n\n-   *lgl* stands for logical, vectors that contain only TRUE or FALSE (True, False, True).\n\n-   *date* stands for dates (01/18/2021).\n\n-   *dttm* stands for date-times, a date + a time (01/18/2021 11:00 am).\n\n### Data structures\n\nOnly the most used ones are covered below:\n\n-   *Vector*: An atomic vector (or simply vector) is the simplest data structure in R which consists of an ordered set of values of the same type (e.g. numeric, character, date, etc…).\n\n#### Examples:\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\ndepartments <- c(\"OMIS\", \"Finance\", \"Accounting\" , \"Management\",\"Marketing\")# a vector can be created using the combine function c()\n#departments\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nstudents_number <- c(220, 180, 255, 100, 170)#all the elements of a vector must have the same data type. This is why the data type determines the type of vector you have (e.g., numeric, characters, date vectors).\n#students_number\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nstudents_avg_age <- c(21.5, 22.1, 21.8, 21.3, 21.5)\n#students_avg_age\n```\n:::\n\n\n\n\n-   *Dataframe/tibble/dataset*: A dataframe is a data structure that organizes data into a 2-dimensional table of rows and columns, much like a spreadsheet. Dataframes are called tibbles in R (tidyverse).\n\nWe can create a tibble by combining two or more vectors of the same length.\n\n#### Example:\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\ncob <- tibble(departments,students_number,students_avg_age)# each vector was of 5 elements (or length 5) --> this is why the cob dataframe has 5 rows. We are using three vectors in our cob dataframe --> this is why we have 3 columns or variables. As you can see the vector name has become the column name and a tibble is not much different than an Excel spreadsheet\n#cob\n```\n:::\n\n\n\n\n*NOTE*: there are other data structures available in R (e.g., matrices, lists etc.) but we will not use or cover them in this course.\n\nNow that you have a basic understanding of data types and structures (we will cover more about tibble next week) we can dive into useful functions for wrangling your data.\n\n### 5 + 1 Key data manipulation (dplyr package) functions:\n\n-   Pick observations based on their values (*filter()*).\n\n-   Reorder the rows/columns (*arrange()*).\n\n-   Pick variables based their column names (*select()*).\n\n-   Create new variables or update existing variables (*mutate()*).\n\n-   Collapse many values down to a single summary (*summarise()*).\n\n-   All the above functions can be used in conjunction with the function *group_by()* (our +1 function). group_by changes the scope of each function from operating on the entire dataset to operating on it group-by-group.\n\n#### How they work?\n\nThese six functions provide the verbs for a language of data manipulation. All verbs work similarly, and this is a great news, and have a similar structure:\n\nThe first argument is a dataframe on which you want to perform a manipulation.\n\nThe subsequent arguments describe what do you want to do with the original dataframe, using the variable names (without quotes).\n\nThe result is a new dataframe (remember to assign it to a new object if you want to preserve the changes). Together these properties make it easy to chain together multiple simple steps to achieve a complex result.\n\n## Filter()\n\n**filter()** is used to include in your dataset only observations that meet one or more logical conditions. For example, you will use filter if from an imaginary US tax payers dataset (tax_payers), you want to continue your analysis only on tax payers that live in Illinois given a states variable (notice that by doing so \\# of observations/rows decreases while \\# of variables/columns stays the same). --\\> **filter(tax_payers, state== \"IL\")**\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Example: flights that traveled on January (Note the # of observation included in the dataset)\nfilter(#the results do not replace the original dataset. To save it to future analysis assign it to a new variable named jan_flights. Create the variable jan_flights \n #<- \n# print jan_flights\n#Example 2: flights that traveled to Ohare (ORD)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:7:0: unexpected end of input\n5: #Example 2: flights that traveled to Ohare (ORD)\n6: \n  ^\n```\n\n\n:::\n:::\n\n\n\n\nTo use filtering effectively, you have to know how to select the observations that you want using the comparison operators. R provides the standard suite: \\>, \\>=, \\<, \\<=, != (not equal), and == (equal).\n\nWhen you’re starting out with R, the easiest mistake to make is to use = instead of == when testing for equality. When this happens you’ll get an informative error:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(flights, month = 1)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in `filter()`:\n! We detected a named input.\nℹ This usually means that you've used `=` instead of `==`.\nℹ Did you mean `month == 1`?\n```\n\n\n:::\n:::\n\n\n\n\nMultiple arguments to filter() are combined with “and”: every expression must be true in order for a row to be included in the output. For other types of combinations, you’ll need to use Boolean operators yourself: & is “and”, \\| is “or”, and ! is “not”. The \",\" can also be used instead of &. However, I do recommend to use & especially at the beginning as it is easier for you to remind that both conditions must be met for an observation to be included in the analysis. However, if you combine an \"&\" and \"\\|\" in the same filter you need parenthesis to separate the \"&\" and the \"\\|\" (see below note).\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Example 3: find flights in November and December\nfilter(# look at the results. Does it make sense to have such filter?\n\n#Example 4: find flights in November or December\nfilter(# Now this makes sense as you want to constraint the focus of your analysis to the last two months of the year. You might have an intuition that during the holiday season there is need for more flights/personnel \n\n# Example 5: find flights that weren’t delayed (on arrival or departure) by more than two hours \nfilter(# Hours are presented in minutes in the dataset that's why 120. Again, you need to get to know your data before starting manipulations. If you don't remember column names check the colnames function (?colnames).\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:10:0: unexpected end of input\n8: filter(# Hours are presented in minutes in the dataset that's why 120. Again, you need to get to know your data before starting manipulations. If you don't remember column names check the coln\n9: \n  ^\n```\n\n\n:::\n:::\n\n\n\n\n### Activity 1: Filter\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights in january with more than 60 minutes delay\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights with departure or arrival delay smaller than 15 minutes\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights with distance equal or bigger than 1010 miles\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights operated by american airlines (AA)\n```\n:::\n\n\n\n\n#### NOTE\n\nBe careful in using & and , as substitutes. In some cases they are but in other not. For example if you are looking for the flights in January with more than 60 minutes delay both in departure and arrival\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nfilter(flights, month==1 & dep_delay> 60 & arr_delay>60)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 80 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1    31     2029           1900        89     2151           2018\n 2  2013     1    31     2051           1750       181     2217           1908\n 3  2013     1    30     2322           2000       202      129           2224\n 4  2013     1     2     2148           2004       104     2234           2112\n 5  2013     1    25     2051           1910       101        8           2215\n 6  2013     1    31     2130           2000        90     2235           2114\n 7  2013     1    23      836            655       101     1049            927\n 8  2013     1    23     1949           1745       124     2226           2020\n 9  2013     1     4     1430           1240       110     1717           1540\n10  2013     1    16     1741           1530       131     1933           1711\n# ℹ 70 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nthis line is equivalent to the one below with ,.\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nfilter(flights, month==1 , dep_delay> 60 , arr_delay>60)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 80 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1    31     2029           1900        89     2151           2018\n 2  2013     1    31     2051           1750       181     2217           1908\n 3  2013     1    30     2322           2000       202      129           2224\n 4  2013     1     2     2148           2004       104     2234           2112\n 5  2013     1    25     2051           1910       101        8           2215\n 6  2013     1    31     2130           2000        90     2235           2114\n 7  2013     1    23      836            655       101     1049            927\n 8  2013     1    23     1949           1745       124     2226           2020\n 9  2013     1     4     1430           1240       110     1717           1540\n10  2013     1    16     1741           1530       131     1933           1711\n# ℹ 70 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nIn this case & and , are perfect substitutes but it is not always the case. Let's check the example below:\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nfilter(flights, month==1 & dep_delay> 60 |arr_delay>60)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,278 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013    12     5     1238           1110        88     1342           1223\n 2  2013    12    18     1704           1509       115     1933           1742\n 3  2013     9    20     1506           1345        81     1635           1523\n 4  2013     5    20     1105           1003        62     1314           1212\n 5  2013     7     7      721            600        81      822            715\n 6  2013     5     3     1413           1200       133     1554           1338\n 7  2013     7    27     1432           1315        77     1614           1505\n 8  2013     1    31     1934           1855        39     2333           2210\n 9  2013    12    27     2315           2219        56      408            304\n10  2013     7     2     2034           1930        64        5           2248\n# ℹ 1,268 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nfilter(flights, month==1 , dep_delay> 60 |arr_delay>60)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1    31     1934           1855        39     2333           2210\n 2  2013     1    31     2029           1900        89     2151           2018\n 3  2013     1    31     2051           1750       181     2217           1908\n 4  2013     1    31     1040           1000        40     1419           1310\n 5  2013     1    30     2322           2000       202      129           2224\n 6  2013     1     2     2148           2004       104     2234           2112\n 7  2013     1    25     2051           1910       101        8           2215\n 8  2013     1    31     2130           2000        90     2235           2114\n 9  2013     1    23      836            655       101     1049            927\n10  2013     1    23     1949           1745       124     2226           2020\n# ℹ 90 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nIn fact, the \\| is affecting the equivalency with the ,. So, if in your filter you have both a & and \\|, the & and the , are not equivalent.\n\nTo achieve equality in this case, you need parenthesis to divide the & and \\| conditions.\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nfilter(flights, month==1 & (dep_delay> 60 |arr_delay>60))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1    31     1934           1855        39     2333           2210\n 2  2013     1    31     2029           1900        89     2151           2018\n 3  2013     1    31     2051           1750       181     2217           1908\n 4  2013     1    31     1040           1000        40     1419           1310\n 5  2013     1    30     2322           2000       202      129           2224\n 6  2013     1     2     2148           2004       104     2234           2112\n 7  2013     1    25     2051           1910       101        8           2215\n 8  2013     1    31     2130           2000        90     2235           2114\n 9  2013     1    23      836            655       101     1049            927\n10  2013     1    23     1949           1745       124     2226           2020\n# ℹ 90 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n\n\nWithout the parenthesis you will get different & wrong results as above. So, please be careful and keep this in mind.\n\n## Arrange()\n\n**arrange()** works similarly to filter() except that instead of selecting rows, it changes the order in which they are presented in the dataset. For example, using the above US tax payers dataset, you will use arrange if you want to sort the dataset by the tax payers last name in decreasing order (Z-A). --\\> **arrange(tax_payers, desc(last_name))** Arrange takes a dataframe and a set of column names (or more complicated expressions) to order by. If you provide more than one column name, each additional column will be used to break ties in the values of preceding columns:\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\narrange(flights, year, month, day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,000 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1     1044           1041         3     1339           1350\n 2  2013     1     1     1730           1730         0     2013           1959\n 3  2013     1     1      723            725        -2     1013           1017\n 4  2013     1     1      732            729         3     1041           1039\n 5  2013     1     1      752            759        -7      955            959\n 6  2013     1     1     1240           1229        11     1451           1428\n 7  2013     1     1      600            600         0      851            858\n 8  2013     1     1     1744           1720        24     2052           2025\n 9  2013     1     1     1653           1700        -7     2005           2018\n10  2013     1     1     1649           1639        10     1937           1911\n# ℹ 14,990 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n#arrange(flights, desc(dep_delay))#desc allows to re-order by a column in descending order\n# Example 1: arrange the dataset based on destination increasing alphabetical order\n\n#Example 2: arrange the dataset based on distance decreasing order\n```\n:::\n\n\n\n\n### Activity 2: Arrange\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights by distance from smaller to bigger\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights by air time\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights with distance equal or bigger than 1010 miles\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#flights by arr_delay from bigger to smaller\n```\n:::\n\n\n\n\n## Select()\n\n**select()** allows you to continue the analysis only on some specific columns of your original dataset. By using select you can rapidly zoom in on a useful subset of variables that you think needs deeper investigation or that are part of the scope of your analysis. For example, using the same imaginary US tax payer dataset, you want to focus your analysis on just salary, gender and age. It is unnecessary to keep all the other columns as you already know that they are not going to be included in the scope of the analysis --\\> **select(tax_payers, salary, gender, age)**\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nselect(flights, year, month, day)#Select columns by name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,000 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     4\n 2  2013    12     5\n 3  2013     8    19\n 4  2013     4    14\n 5  2013     4    29\n 6  2013     4     5\n 7  2013     1    17\n 8  2013     2    26\n 9  2013     2    20\n10  2013     3    22\n# ℹ 14,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(flights, year:day)#Select all columns between year and day (inclusive)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,000 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     4\n 2  2013    12     5\n 3  2013     8    19\n 4  2013     4    14\n 5  2013     4    29\n 6  2013     4     5\n 7  2013     1    17\n 8  2013     2    26\n 9  2013     2    20\n10  2013     3    22\n# ℹ 14,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(flights, 1:3)#Select columns based on their position in the dataset (inclusive)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,000 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     4\n 2  2013    12     5\n 3  2013     8    19\n 4  2013     4    14\n 5  2013     4    29\n 6  2013     4     5\n 7  2013     1    17\n 8  2013     2    26\n 9  2013     2    20\n10  2013     3    22\n# ℹ 14,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nselect(flights, -(year:day))# Select all columns except those from year to day (inclusive)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,000 × 16\n   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier\n      <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>  \n 1      819            820        -1     1103           1129       -26 B6     \n 2     1238           1110        88     1342           1223        79 EV     \n 3     1953           1959        -6     2141           2146        -5 EV     \n 4      608            610        -2      752            754        -2 EV     \n 5     1653           1700        -7     1815           1835       -20 MQ     \n 6     1813           1729        44     2026           1937        49 EV     \n 7     1740           1745        -5     2054           2120       -26 AA     \n 8      834            815        19     1031           1010        21 MQ     \n 9     1014           1000        14     1219           1221        -2 EV     \n10     1741           1736         5     2024           2029        -5 B6     \n# ℹ 14,990 more rows\n# ℹ 9 more variables: flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# Example 1: select the 2nd, 4th and 10th columns \n\n#Example 2: select all the columns but the last 3\n```\n:::\n\n\n\n\nAs you can see there are multiple ways to select the same columns (first 3 lines of code give the same outcome: year, month , day subset), but not all of them have the same efficiency. Imagine selecting the first 15 column using the first line of code (you will have to manually type 15 columns name) compared to using the second line (first column : fifteenth column) or the third (1:15). However, when you use the last two methods I recommend to check the column order using the function *colnames()*\n\nMoreover, there are a number of helper functions you can use within select():\n\n*starts_with(\"abc\")*: matches names that begin with “abc”.\n\n*ends_with(\"xyz\")*: matches names that end with “xyz”.\n\n*contains(\"ijk\")*: matches names that contain “ijk”.\n\nSee ?select for more details.\n\n### Activity 3: Select\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#first 10 adjacent columns\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#columns that contain the word \"time\"\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#all columns but those that contain the word \"time\"\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#columns that start with the letter \"d\"\n```\n:::\n\n\n\n\n## Mutate()\n\n**mutate()** enables you to change the columns available in your original dataset. By using mutate() you can add new columns that are functions of existing columns. For example, in the tax_payers dataset, you note that the salary column is reported in euros rather than dollars. In this case, you want to create a new column that reports salary in euros. To do so you need to multiple the value that are in the original salary by the conversion rate between euros and dollars. --\\> **mutate(tax_payers, salary_USD = salary \\* 1.21)**. Note how I chose a meaningful name for the new column, and that the conversion rate at the time I created this rmd file was 1.21.\n\nMoreover, keep in mind that mutate() always adds new columns at the end of your dataset. So, to view the new column you can use **View(tax_payers)** or **select(tax_payers, salary_USD)**. Nonetheless, If you want to just use the new compute column you can also use the **transmute()** function (see example below).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights_sml <- select(flights, \n  year:day, \n  ends_with(\"delay\"), \n  distance, \n  air_time\n)# what is the purpose of running this?\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# Example 1: using the flights_sml dataset compute a column named gain equal to the difference between departure delay and arrival delay\nmutate(\n  \n# Example 2: using the flights_sml dataset compute a column named gain equal to the difference between departure delay and arrival delay; a column named hours equal to air time dived by 60; and a column named gain_per_hour equal to gain divided by hours.\nmutate( # you can refer to column your are just creating, be careful to the order. Can you invert the order of gain_per_hour and gain. Let's try!\n\n# Example 3: using the flights_sml dataset  compute a column named speed equal to the variable distance divided by air time multiplied by 60 (we want speed in mph). Use transmute instead of mutate. What is the difference?\ntransmute(#If you only want to keep the new variables, use transmute()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:10:0: unexpected end of input\n8: transmute(#If you only want to keep the new variables, use transmute()\n9: \n  ^\n```\n\n\n:::\n:::\n\n\n\n\n### Activity 4: Mutate\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#compute a variable that shows the difference between scheduled departure time and the actual time of departure\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#compute a variable that shows the air time divided by the total flight distance\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#compute a variable that shows the difference between scheduled arrival time and the actual time of arrival\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n##compute a variable that shows the sum of the departure delay and the air time\n```\n:::\n\n\n\n\n## Summarise()\n\n**summarise()** enables you to compute descriptive statistics of your dataset. summarise() collapses a dataframe to a single row. For example, if you want to compute the average salary of the observation of the tax payers in your dataset, summarise will return to you one row that contains the average value. --\\> **summarise(tax_payers, avg_salary = mean(salary))**. Note how I chose a meaningful name for the output of my summary.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarise(flights, avg_delay = mean(dep_delay, na.rm = TRUE))# we will talk later about NAs (missing values) but the na.rm=TRUE argument is critical if the column you are using for your average contains missing values. Let's remove that argument amd see what happens.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  avg_delay\n      <dbl>\n1      13.1\n```\n\n\n:::\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# Example 1: compute the mean of the arrival delay column\n\n# Example 2: find the max distance\n```\n:::\n\n\n\n\nsummarise() is not terribly useful unless we pair it with **group_by()** or better it is pretty limited to summarise a single value per column. For example, imagine that you want to see how the average salary of tax payers change depending on their age. In this case, you need to first group_by your dataset using the age column and then compute the average salary. Thanks to the combination of group_by and summarise you will able to explore if the average salary of a 40 years old tax payer is on average higher/lower or equal to the ones of a 21 years old tax payer.\n\n## Summarise + group_by()\n\nSo, when you use the group_by() function you can change the unit of analysis from the complete dataset to individual groups (columns that caught your attention). group_by will create a group for each unique value available in the selected column.Then, when you use the dplyr verbs on a grouped dataframe they’ll be automatically applied “by group”. For example, if we applied exactly the same code to a dataframe grouped by date, we get the average delay per date:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_day <- group_by(flights, year, month, day)\nsummarise(by_day, avg_delay_date = mean(dep_delay, na.rm = TRUE))#help in answer the question about how dates are affecting the delay\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day avg_delay_date\n   <int> <int> <int>          <dbl>\n 1  2013     1     1         16.7  \n 2  2013     1     2          6.53 \n 3  2013     1     3         16.4  \n 4  2013     1     4         22.5  \n 5  2013     1     5          1.15 \n 6  2013     1     6          4.42 \n 7  2013     1     7          4.75 \n 8  2013     1     8          3.49 \n 9  2013     1     9          0.432\n10  2013     1    10          0.396\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Example 1: do the same analysis for each airlines. Call the column avg_dalay_carrier.\nby_carrier\nsummarise(#help in answer the question about how the airlines are affecting the delay\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: <text>:4:0: unexpected end of input\n2: by_carrier\n3: summarise(#help in answer the question about how the airlines are affecting the delay\n  ^\n```\n\n\n:::\n:::\n\n\n\n\nTogether group_by() and summarise() provide one of the tools that you’ll use most commonly when working with dplyr: grouped summaries. These two functions are extremely useful to create descriptives statistics of the column of your dataset.\n\n### Activity 5: Summarise\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#compute the max dep_delay\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#compute the min air_time\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#compute mean and standard deviation of the distance per each destination\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#compute the max and min of air_time per each month\n```\n:::\n\n\n\n\n### Data Inside R\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Running this code is the equivalent of simply running the name of the dataset you want to print. Meaning default printing will be applied\nflights# but what if I want to print in console all columns?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15,000 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     4      819            820        -1     1103           1129\n 2  2013    12     5     1238           1110        88     1342           1223\n 3  2013     8    19     1953           1959        -6     2141           2146\n 4  2013     4    14      608            610        -2      752            754\n 5  2013     4    29     1653           1700        -7     1815           1835\n 6  2013     4     5     1813           1729        44     2026           1937\n 7  2013     1    17     1740           1745        -5     2054           2120\n 8  2013     2    26      834            815        19     1031           1010\n 9  2013     2    20     1014           1000        14     1219           1221\n10  2013     3    22     1741           1736         5     2024           2029\n# ℹ 14,990 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n?flights#get info about the dataset\ncolnames(flights)#get the columns in the dataset\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"year\"           \"month\"          \"day\"            \"dep_time\"      \n [5] \"sched_dep_time\" \"dep_delay\"      \"arr_time\"       \"sched_arr_time\"\n [9] \"arr_delay\"      \"carrier\"        \"flight\"         \"tailnum\"       \n[13] \"origin\"         \"dest\"           \"air_time\"       \"distance\"      \n[17] \"hour\"           \"minute\"         \"time_hour\"     \n```\n\n\n:::\n\n```{.r .cell-code}\nglimpse(flights)#useful way to collapse the content in a summary format\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 15,000\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 12, 8, 4, 4, 4, 1, 2, 2, 3, 1, 2, 12, 8, 7, 9, 9, 12…\n$ day            <int> 4, 5, 19, 14, 29, 5, 17, 26, 20, 22, 25, 18, 13, 5, 29,…\n$ dep_time       <int> 819, 1238, 1953, 608, 1653, 1813, 1740, 834, 1014, 1741…\n$ sched_dep_time <int> 820, 1110, 1959, 610, 1700, 1729, 1745, 815, 1000, 1736…\n$ dep_delay      <dbl> -1, 88, -6, -2, -7, 44, -5, 19, 14, 5, 4, -2, -5, -7, 1…\n$ arr_time       <int> 1103, 1342, 2141, 752, 1815, 2026, 2054, 1031, 1219, 20…\n$ sched_arr_time <int> 1129, 1223, 2146, 754, 1835, 1937, 2120, 1010, 1221, 20…\n$ arr_delay      <dbl> -26, 79, -5, -2, -20, 49, -26, 21, -2, -5, -4, -19, -9,…\n$ carrier        <chr> \"B6\", \"EV\", \"EV\", \"EV\", \"MQ\", \"EV\", \"AA\", \"MQ\", \"EV\", \"…\n$ flight         <int> 181, 4633, 4462, 4555, 4255, 4621, 177, 4490, 3810, 9, …\n$ tailnum        <chr> \"N527JB\", \"N14974\", \"N11176\", \"N14148\", \"N645MQ\", \"N145…\n$ origin         <chr> \"JFK\", \"EWR\", \"LGA\", \"LGA\", \"JFK\", \"EWR\", \"JFK\", \"LGA\",…\n$ dest           <chr> \"SAN\", \"BTV\", \"CLE\", \"CLE\", \"BNA\", \"CVG\", \"SFO\", \"CMH\",…\n$ air_time       <dbl> 312, 47, 62, 73, 108, 92, 352, 80, 109, 135, 190, 138, …\n$ distance       <dbl> 2446, 266, 419, 419, 765, 569, 2586, 479, 708, 944, 159…\n$ hour           <dbl> 8, 11, 19, 6, 17, 17, 17, 8, 10, 17, 7, 6, 7, 11, 15, 8…\n$ minute         <dbl> 20, 10, 59, 10, 0, 29, 45, 15, 0, 36, 10, 59, 7, 15, 5,…\n$ time_hour      <dttm> 2013-01-04 08:00:00, 2013-12-05 11:00:00, 2013-08-19 1…\n```\n\n\n:::\n\n```{.r .cell-code}\nflights |> \n  view()# the other option to print more rows and actually all rows is still the view () function discussed in week 1 to open the dataset in a new window\n\n# \" |> \" # is the pipe operator and it is used to combine functions and apply them to variables within the tidyverse package. The shortcut for the pipe operator is cmd/ctrl + shift+ M. More of its application later in the class.\n```\n:::\n\n\n\n\n### Importing data\n\nBut what happen when your data come from outside of R? It is time to learn how to import external data. To load flat files in R we will use the readr package, which is part of the core tidyverse package. Most of readr’s functions are concerned with turning flat files into dataframes (e.g, csv files but similar functions exist also for Excel files or other delimited files). These functions all have similar syntax: once you’ve mastered one, you can use the others with ease. In this course we’ll focus on read_csv(). Not only are csv files one of the most common forms of data storage, but once you understand read_csv(), you can easily apply your knowledge to all the other functions in readr.\n\nThe first argument to read_csv() is the most important: it’s the path to the file to read. Once again if your file is in your project folder, you will not have any troubles to access it:\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nheights <- read_csv(\"heights.csv\")#When you run read_csv() it prints out a column specification that gives the name and type of each column. #the heights.csv is available for download on Blackboard in the week 3 module. If this code doesn't work, make sure to move the file in your project folder.\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError: 'heights.csv' does not exist in current working directory ('C:/Users/venka/OneDrive - Northern Illinois University/Desktop/Vineel/Vineel/TA work/Fall_2024/Code Base/omis482-f2024-class-website/docs').\n```\n\n\n:::\n:::\n\n\n\n\n#### NOTE\n\nread_csv() uses the first line of the data for the column names, which is a very common convention. The data might not have column names. You can use col_names = FALSE to tell read_csv() not to treat the first row as headings, and instead label them sequentially from X1 to Xn. The function will guess the data type of each column by looking at the first 1000 rows. It is your responsibility to make sure that the columns type are correct. For more info look the parsing sections 11.3 and 11.4. To get other types of data into R, I recommend starting with the tidyverse packages listed below:\n\n-   haven package: reads SPSS, Stata, and SAS files.\n\n-   readxl package: reads excel files (both .xls and .xlsx).\n\n-   DBI package: along with a database specific backend (e.g. RMySQL, RSQLite, RPostgreSQL etc) allows you to run SQL queries against a database and return a data frame.\n\n### Writing data\n\nNow that we have seen how to bring data into RStudio, what about exporting data from RStudio? The readr package comes also with two useful functions for writing data back to disk: write_csv() and write_tsv(). If you want to export a csv file to Excel, use write_excel_csv(). The most important arguments are x (the data frame to save), and path (the location to save it).\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nwrite_csv(nycflights13::flights, \"flights.csv\")#I am exporting the flights dataset and writing it into a csv file called flights.csv. After running the code that file will be available in your working directory (which should be your project folder)\n```\n:::\n\n\n\n\n## Pipes\n\nYou probably have seen the pipe symbol before but let's learn how it works and why it is so important in tidyverse. Before we do that please keep in mind that two types of pipes exist:\n\n-   The magrittr pipe %\\>% that comes from the magrittr package created by Stefan Milton Bache. Packages in the tidyverse load %\\>% for you automatically, so you don’t usually load magrittr explicitly. While magrittr pipe was used for a while in the tidyverse world, it is now losing its traction.\n-   In fact, the native pipe \\|\\> is becoming more popular and it is most commonly used.\n\nFor this course we will use only the native pipe \\|\\>. While for simple cases, \\|\\> and %\\>% behave identically only the native pipe is part of base R, and so it’s always available for you to use, even when you’re not loading the tidyverse. Moreover, \\|\\> is simpler than %\\>% and it works better with more advanced tasks.\n\nHowever, you might need to make one change to your RStudio options to use \\|\\> instead of %\\>% by accessing the Code Editing tab of your Project Option; After you made this change you can add the native pipe to your code by using the built-in keyboard shortcut Ctrl/Cmd + Shift + M.\n\n### Combining multiple operations with the pipe\n\nImagine that we want to explore the relationship between the distance and average delay for each destination. There are three steps to prepare our original flights data:\n\n-   Group flights by destination.\n\n-   Summarise to compute average distance, average delay, and number of flights.\n\n-   Filter to remove noisy points (less than 20 observations, small sample) and Honolulu airport (almost twice as far away as the next closest airport).\n\nIf we put in practice what we learned so far, this code is a little frustrating to write because we have to give each intermediate data frame a name, even though we don’t care about it. Naming things is hard, so this slows down our analysis.\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nby_dest <- group_by(flights, dest)\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\ndelay <- summarise(by_dest,\n  count = n(),\n  avg_dist = mean(distance, na.rm = TRUE),\n  avg_delay = mean(arr_delay, na.rm = TRUE)\n)#know how many flights go to each destination [n()]; average distance and average delay for flights at each destination\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\ndelay_filtered <- filter(delay, count > 20, dest != \"HNL\")#now let's remove all destinations that have less or equal to 20 flights and let's exclude Honululu from it. Notice how many assignment I need to create the desired object (3)\n```\n:::\n\n\n\n\nThere’s another, much simpler and efficient, way to tackle the same problem thanks to the pipe operator, \\|\\>, because we can combine manipulations together:\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nfiltered_delay <- flights |> \n  group_by(dest) |> \n  summarise(\n    count = n(),\n    avg_dist = mean(distance, na.rm = TRUE),\n    avg_delay = mean(arr_delay, na.rm = TRUE)\n  ) |> \n  filter(count > 20, dest != \"HNL\") #Notice how many assignment I need to create the desired object (1), two less than the previous code.\n```\n:::\n\n\n\n\nAnyway, what is great about using pipe is that your code now focuses on the transformations, and not anymore on what’s being transformed, which makes the code easier to read. In fact, the best way to read the above code is to take each line before the pipe as an imperative statement (remember that the dataset us always the starting point). - Take the flights dataset, then - Group it by destination, then - summarise it (I want the number of flights at each destination, the average distance and the average delay of each destination), then - Filter the results and include only those destinations with more than 20 flights and exclude Honululu.\n\nAs suggested by this reading, a good way to pronounce \\|\\> when reading code is “then”. So, remember that you can use the pipe to rewrite multiple operations in a way that you can read left-to-right, top-to-bottom. We’ll use piping from now on because it considerably improves the readability of code and it makes your code more efficient. Working with the pipe is one of the key criteria for belonging to the tidyverse world!\n\nBy the way we can use the pipe also to what we have already learned ;-)\n\n### Activity 6: Basic pipes\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# keep only the flights in February with more than 75 minutes delay\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# sort the flights by air_time from bigger to smaller\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# keep all columns but those that contain the word \"dep\"\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# compute a column named gain equal to the difference between departure delay and arrival delay\n```\n:::\n\n\n\n\n### Missing values\n\nOk now it is time to provide an explanation on the **na.rm** argument that we used in the summarise function. Let's try one more time in not using it. What happens if we don’t have it?\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(year, month, day) |> \n  summarise(mean = mean(dep_delay))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day   mean\n   <int> <int> <int>  <dbl>\n 1  2013     1     1 16.7  \n 2  2013     1     2 NA    \n 3  2013     1     3 16.4  \n 4  2013     1     4 22.5  \n 5  2013     1     5  1.15 \n 6  2013     1     6  4.42 \n 7  2013     1     7  4.75 \n 8  2013     1     8  3.49 \n 9  2013     1     9  0.432\n10  2013     1    10 NA    \n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n\n\nWe get a lot of missing values! That’s because aggregation functions obey the usual rule of missing values: if there’s any missing value in the input, the output will be a missing value. Fortunately, all aggregation functions have an na.rm argument which removes the missing values prior to computation:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(year, month, day) |> \n  summarise(mean = mean(dep_delay, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day   mean\n   <int> <int> <int>  <dbl>\n 1  2013     1     1 16.7  \n 2  2013     1     2  6.53 \n 3  2013     1     3 16.4  \n 4  2013     1     4 22.5  \n 5  2013     1     5  1.15 \n 6  2013     1     6  4.42 \n 7  2013     1     7  4.75 \n 8  2013     1     8  3.49 \n 9  2013     1     9  0.432\n10  2013     1    10  0.396\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n\n\nIn this case, missing values represent cancelled flights. So, we could also tackle the problem by first removing all the cancelled flights. By doing so we get rid of all missing values and so of the need of using the na.rm argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_cancelled <- flights |> \n  filter(!is.na(dep_delay), !is.na(arr_delay))#save this dataset so we can reuse it in the future.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_cancelled |> \n  group_by(year, month, day) |> \n  summarise(mean = mean(dep_delay))#no need of na.rm since we don't have NAs anymore\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day   mean\n   <int> <int> <int>  <dbl>\n 1  2013     1     1 16.7  \n 2  2013     1     2  6.53 \n 3  2013     1     3 16.4  \n 4  2013     1     4 22.5  \n 5  2013     1     5  1.15 \n 6  2013     1     6  4.42 \n 7  2013     1     7  4.75 \n 8  2013     1     8  3.49 \n 9  2013     1     9  0.432\n10  2013     1    10  0.396\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### Why producing counts matters?\n\nWe have already seen how to count observations. However, it is extremely important that you keep in mind that whenever you do any aggregation, it’s always a good idea to include either a count (n()), or a count of non-missing values (sum(!is.na(x))). That way you can check that you’re not drawing conclusions based on very small amounts of data. Results and conclusions based on few observations contain noise and are drawn based on a small number of events and can lead to incorrect insights.\n\n*Imaginary Scenario*: Let's talk about flight delays and why we can't always compare them from different times like before, during, and after the pandemic. Things change, and comparisons might not be fair.\n\nImagine a new direct flight from DeKalb to Potenza. On its first trip, something rare happens: a passenger gets sick, and because of a new rule, the flight is delayed for 14 hours while they wait for a health check.\n\nIf we only look at this one flight, we might think the average delay for this route is 14 hours. But that's not true, it's just one unusual case. We can't say all flights on this route are always delayed like this based on one incident. We need more flights to make a fair judgment. If after many flights the delay is still long, then we might think it's a bad route. But for now, it's too early to decide based on just one flight.\n\nI hope the scenario made the point on the importance of count clear. Now let's use a real data example and let’s look at the planes (identified by their tail number) that have the highest average delays:\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nnot_cancelled |> \n  group_by(tailnum) |> \n  summarise(\n    delay = mean(dep_delay))# no info about how many flights each tailnum has made. Which one seem the most problematic? \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,088 × 2\n   tailnum delay\n   <chr>   <dbl>\n 1 N0EGMQ   3.81\n 2 N10156  54   \n 3 N102UW  -1   \n 4 N103US   0   \n 5 N104UW  28.7 \n 6 N10575  30   \n 7 N105UW  -8   \n 8 N107US  -2.5 \n 9 N108UW  -3   \n10 N110UW  -3   \n# ℹ 3,078 more rows\n```\n\n\n:::\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\nnot_cancelled |> \n  group_by(tailnum) |> \n  summarise(\n    delay = mean(dep_delay, na.rm = TRUE), n = n())#now you also now on how many flights your average is based on. You don't want to base any conclusion on a small number of observation. Check the # of flights for the tail number D942DN\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,088 × 3\n   tailnum delay     n\n   <chr>   <dbl> <int>\n 1 N0EGMQ   3.81    16\n 2 N10156  54        4\n 3 N102UW  -1        1\n 4 N103US   0        2\n 5 N104UW  28.7      3\n 6 N10575  30       19\n 7 N105UW  -8        1\n 8 N107US  -2.5      2\n 9 N108UW  -3        3\n10 N110UW  -3        1\n# ℹ 3,078 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### Recap of the summary functions\n\nJust using means and counts can get you a long way, but R provides many other useful summary functions that should be taken in consideration when producing descriptive statistics. Here is a list of the most useful ones with many opportunities to practice them in the activities belpw:\n\n-   Measures of location: mean(x) and median(x) . The mean is the sum divided by the length; the median is a value where 50% of x is above it, and 50% is below it.\n\n-   Measures of spread: sd(x). The root mean squared deviation, or standard deviation sd(x), is the standard measure of spread.\n\n-   Measures of rank: min(x) and max(x). The min will help you identify the smallest value, while the max allows you to find the largest value in column.\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#measures of location example\nnot_cancelled |> \n  group_by(year, month, day) |> \n  summarise(\n    avg_delay = mean(dep_delay),\n    median_delay = median(dep_delay)) # the average positive delay\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 5\n# Groups:   year, month [12]\n    year month   day avg_delay median_delay\n   <int> <int> <int>     <dbl>        <dbl>\n 1  2013     1     1    16.7              0\n 2  2013     1     2     6.53            -1\n 3  2013     1     3    16.4              0\n 4  2013     1     4    22.5              1\n 5  2013     1     5     1.15            -2\n 6  2013     1     6     4.42            -3\n 7  2013     1     7     4.75            -2\n 8  2013     1     8     3.49            -2\n 9  2013     1     9     0.432           -4\n10  2013     1    10     0.396           -4\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#measures of spread example\nnot_cancelled |> \n  group_by(dest) |> \n  summarise(distance_sd = sd(distance)) |> \n  arrange(desc(distance_sd))# Is distance to some destinations more variable than to others?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 99 × 2\n   dest  distance_sd\n   <chr>       <dbl>\n 1 HNL         10.2 \n 2 LAS         10.2 \n 3 PDX         10.1 \n 4 SFO          9.99\n 5 SAN          9.98\n 6 PHX          9.88\n 7 SEA          9.86\n 8 EGE          9.61\n 9 LAX          9.56\n10 CVG          9.17\n# ℹ 89 more rows\n```\n\n\n:::\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#measures of rank example\nnot_cancelled |> \n  group_by(year, month, day) |> \n  summarise(\n    first = min(dep_time),\n    last = max(dep_time)\n  )# When do the first and last flights leave each day?\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 5\n# Groups:   year, month [12]\n    year month   day first  last\n   <int> <int> <int> <int> <int>\n 1  2013     1     1   600  2052\n 2  2013     1     2   558  2215\n 3  2013     1     3   600  2140\n 4  2013     1     4   106  2158\n 5  2013     1     5   555  2204\n 6  2013     1     6   559  2353\n 7  2013     1     7   559  2052\n 8  2013     1     8   623  2119\n 9  2013     1     9   603  2056\n10  2013     1    10   618  2129\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n\n\n### Activity 7: Summary functions p1 (must use the pipe)\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Compute the median of the distance variable per each tail number?\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Compute the median of the arr_delay variable per each carrier?\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Compute the mean and median of the dep_delay variable per each dest?\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Compute the mean and median of the air_time variable per each origin?\n```\n:::\n\n\n\n\n### Activity 8: Summary functions p2 (must use the pipe)\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# Find min and max of the distance variable for each tail number?\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# Find min, max and sd of the air_time variable for each carrier?\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# Find min and max of the dep_delay variable for each month?\n```\n:::\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n# Find min, max and sd of the arr_delay variable for each destination?\n```\n:::\n\n\n\n\n##### Challenge1: You must use the pipe to complete the challenge and not create any intermediate objects (one big chunk of code)\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Use the flights dataset and apply the following manipulations at the same time using pipes:\n#1) Make sure your dataset has only the following columns: month, day, dep_delay, arr_delay, dest, distance, carrier and air_time\n#2) Reorder your data and show them from the highest arr_delay flight to the smallest one.\n#3) Create a column named distance_km that is equal to distance/1.6\n#4) Per each carrier compute the avg_arr_delay, min_arr_delay, max_arr_delay, sd_arr_delay, median_arr_delay and the number of flights operated.\n#5) Keep in the output only the 5 carriers with the lowest median_arr_delay\n```\n:::\n\n\n\n\n##### Challenge2: You must use the pipe to complete the challenge and not create any intermediate objects (one big chunk of code)\n\n\n\n\n::: {.cell exercise='true'}\n\n```{.r .cell-code}\n#Use the flights dataset and apply the following manipulations at the same time using pipes:\n#1) Keep only flights departed from JFK in February\n#2) Make sure your dataset has only the following columns: day, dep_delay, arr_delay, dest,and carrier \n#3) Create a column named final_delay that is equal to arr_delay- dep_delay\n#4) Per each dest compute the avg_final_delay, min_final_delay, max_final_delay, sd_final_delay, median_final_delay and the number of flights landed there.\n#5) Reorder your data and show them from the highest median_final_delay to the smallest one.\n```\n:::\n\n\n\n\n### When not to use the pipe\n\nThe pipe operator is a powerful tool, but it’s not the only tool at your disposal, and it doesn’t solve every problem! Pipes are most useful for rewriting a fairly short linear sequence of operations. I think you should reach for another tool when:\n\n-   Your pipes are longer than (say) ten steps. In that case, create intermediate objects with meaningful names. That will make debugging easier, because you can more easily check the intermediate results, and it makes it easier to understand your code, because the variable names can help communicate intent.\n\n-   You have multiple inputs or outputs. If there isn’t one primary object being transformed, but two or more objects being combined together, don’t use the pipe.\n\n## Now that you know how to manipulate your data.What about learning how to visualize them? See you for more in the next chapter!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}